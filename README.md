# Raspberry Chess 项目报告

## 项目介绍

Raspberry Chess是基于树莓派平台的自动下棋机器人。
整个项目有大约600行Python代码，利用机器视觉和开源象棋引擎，控制机械臂，从而完成与用户对弈的功能。

项目主要分为三个模块：
  * 视觉：识别棋盘和棋子的位置和类别
  * 行棋逻辑：分析用户走法，计算最佳走法
  * 机械臂控制：操作机械臂移动棋子

报告的第二部分是方案设计，例如在几个可能的方案中，我是如何做出选择的。
报告的第三部分是代码的详细文档，以及如何搭建这个项目。


## 方案设计

### 器材的选用
我第一个考虑的问题是，如何让机械臂稳定地抓取和移动棋子？

与中国象棋扁平的棋子不同，国际象棋的棋子大都是立体的，并且顶面并不平整。
我使用的机械臂（越疆魔术师）有两种抓取模式，钩爪和吸盘，但对于形状不规整的棋子来说，这两种模式都不能很好地抓取棋子。
此外，机械臂的另一个问题是臂展相对较短，伸缩幅度只有20cm左右。这就意味着棋盘不能太大。
这两个问题意味着，市面上常见的国际象棋棋盘不能满足项目的需要。

几个可能的解决方案：
  1. 对常见的棋子棋子加以改造，例如在棋子顶端黏贴硬纸板，以方便吸盘吸取。但这并不能解决臂展不足的问题。
  2. 定制棋盘，例如用3D打印自己设计棋子。缺点是比较麻烦。

最终的解决方法比较幸运：我恰好在淘宝上发现了自己需要的那种棋盘(商品链接)[1]。
棋子是平面的，而且棋盘较小，适合机械臂的操作。

[1]: https://item.taobao.com/item.htm?spm=a1z09.2.0.0.69b52e8dbms51T&id=532708644440&_u=s2u449ftcb3f

### 棋盘位置的识别
对棋盘进行图像处理的第一步，就是找出棋盘四个角在图片中的位置，用透视变换让棋盘占据图片的全部。

经过一些调查，我很快发现了OpenCV提供的一个函数：findChessboardCorners()。
这个函数会识别一个黑白棋盘的内部格点。例如，一个8x8的棋盘会识别出7x7个内部格点。
对这些内部格点做一个线性外插，应该就能得到棋盘四个角对应的位置。

我在这个方向上花了两节课时间，试图让findChessboardCorners()能够工作。
但是这个函数的问题也很突出。
  1. findChessboardCorners()的设计初衷是用于摄像头的矫正，而不是识别一个实际的象棋棋盘。因此在棋盘上有棋子时，识别正确率会大大降低。
  2. findChessboardCorners()计算复杂，在树莓派这样的硬件上运行速度很慢（调用一次需要1~2秒）。
  3. 无法分辨哪个是棋盘的“左上角”，哪个是“右下角”等等。

最终我放弃了这个方向。
我的新方案是，在棋盘的四个角贴上四种颜色的贴纸，利用颜色识别四个角。
这个方案的优点是简单方便，运行速度快，准确率高。
但缺点是，四块贴纸的中心与棋盘的四个角并不是完全重合的，需要在代码里手动矫正（比较hacky，第三部分会提到）。

### 棋子类型的识别
有了棋盘的图片，下面只需要把图片切割成8x8的小方格，然后分别识别棋子的类型即可。

这里有个小技巧：我们其实只需要识别棋子的颜色（白子，黑子，空格），而不需要识别棋子的类型（车，象，王，后）。
这是因为，国际象棋的每一步走法都可以用（棋子的出发地，棋子的目的地）这个二元组合唯一地表示。
例如，如果我们知道一步走法的出发点是e2，目的地是e4，那么我们就能判断出，白方的兵从e2走到了e4。
我们将这个状态保存起来，下次再遇见e4的时候，我们就知道这里肯定是一个白兵，不需要通过图像处理的手段识别棋子类型了。

有一个例外，就是兵的升变。国际象棋的规则是，兵在走到底线后，可以变成（后，车，象，马）中的任何一个棋子。
实际的对弈中大部分棋手都会选择变后（因为后最强大），但也有极少数情况，变后不是最佳选择。
不过对我们来说，在出现兵升变的情况时，默认变后已经足够了。

识别棋子类型的算法在第三部分会详细解释。

### 用户着法的分析，最佳着法的获取
在发现棋盘有变动之后，我们就可以通过对比棋盘前后哪些位置有变化，来分析出用户的着法。
之后，将着法历史转换为代数记谱法（例如 ["e2e4", "d7d5", "e4d5"]），传给开源象棋引擎Stockfish，获取机械臂的最佳着法。
我们利用了python-chess的一些功能，可以简化调用Stockfish的过程。

从python-chess和Stockfish获取的最佳着法只包含了简要的走子信息（例如“f3上的马吃e5的兵”），
我们还需要将其转化为机械臂的实际操作流程（例如“先将e5上的棋子移出棋盘，再将f3上的棋子移到e5”）

### 机械臂的定位和校准
至此，最后一步就是让机械臂执行具体的操作指令，例如“将f3上的棋子移到e5”）。

如何定位呢？
最理想的方法是反馈控制，即用摄像头拍摄的实时画面，对机械臂的位置进行微调。但这个方式实现起来太过麻烦。
因此我采用了开环控制，在棋局开始时，让用户将机械臂放置在棋盘中央，之后的定位都按照相对这个中央的位置进行移动。
显然，这个做法会导致误差累积，偶尔会有定位偏差导致吸盘没能抓起棋子。此时我会稍微移动一下棋盘，手动纠正误差。
如果要实现真正的反馈控制，那么图像处理那方面就会更加复杂了。

## 实现细节
